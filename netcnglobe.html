<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Globe</title>
        <style>
			body {
				height: 100vh;
				padding: 0;
				margin: 0;
			}
            #log {
                position: absolute;
                font-size: 12px;
                font-family: sans-serif;
                padding: 5px;
                border-radius: 3px;
                background-color: rgba(200, 200, 200, 0.1);
                color: lavender;
                bottom: 10px;
                right: 10px;
            }
		</style>
        <script src="//unpkg.com/satellite.js/dist/satellite.min.js"></script>
        <script src="//unpkg.com/three"></script>
        <script src="//unpkg.com/three-globe"></script>
        
		<script src="./dat.gui.min.js"></script>
    </head>
    <body>
        <div id="globe"></div>
        <div id="log"></div>
        <script type="importmap">{ "imports": { "three": "https://unpkg.com/three/build/three.module.js" }}</script>
        <script type="module">
            
            import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
            const logger = document.getElementById('log');
            const loader = new THREE.FileLoader();
            // const textureLoader = new THREE.TextureLoader();

            // const assignSRGB = ( texture ) => { texture.colorSpace = THREE.SRGBColorSpace; };

            // const sprite = textureLoader.load('./spark1.png', assignSRGB);

            const scene = new THREE.Scene();                
            const Globe = new ThreeGlobe()
                .globeImageUrl('//unpkg.com/three-globe/example/img/earth-blue-marble.jpg')
                //.bumpImageUrl('//unpkg.com/three-globe/example/img/earth-topology.png')

            function componentToHex(c) {
                var hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            }

            function rgbToHex(red, green, blue) {
                const rgb = (red << 16) | (green << 8) | (blue << 0);
                return '#' + (0x1000000 + rgb).toString(16).slice(1);
            }

            function degToRad(degrees) {
                return degrees * (Math.PI / 180);
                }


            function calcPosFromLatLonRad(rad, lat, lon) {

                var spherical = new THREE.Spherical(
                rad,
                degToRad(90 - lon),
                degToRad(lat)
                );

                var vector = new THREE.Vector3();
                vector.setFromSpherical(spherical);

                console.log(vector.x, vector.y, vector.z);
                return vector;
            }

            loader.load("./output.json", function(jsonData) {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const sizes = [];
                var data = JSON.parse(jsonData);
                var i = 0;
                for(let obj of data){
                    const R = 63.71 * 1.8;
                    const lon = obj.lon;
                    const lat = obj.lat;
                    const elev = obj.elevation /1000;
                    const r = obj.red;
                    const g = obj.green;
                    const b = obj.blue;
                    if (r != 0 && g != 0 && b !=0){
                        const pos = calcPosFromLatLonRad(elev + R, lat, lon)
                        //positions.push(x, y, z);
                        const color = rgbToHex(r, g, b);
                        colors.push(color, color, color);
                        logger.innerText =  lat + " " + lon + " " + elev * 1000;
                          const sphere = new THREE.SphereGeometry(0.05, 3, 2, 0, Math.PI*2, 0, Math.PI);
                          const spheremat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
                          const sp = new THREE.Mesh(sphere, spheremat);
                          scene.add(sp);
                          sp.position.x = pos.x;
                          sp.position.y = pos.y;
                          sp.position.z = pos.z;
                        //sizes.push(10);
                    }
                    // else if(i % 8 == 0){
                    //       const sphere = new THREE.SphereGeometry(0.05, 3, 2, 0, Math.PI*2, 0, Math.PI);
                    //       const spheremat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                    //       const sp = new THREE.Mesh(sphere, spheremat);
                    //       scene.add(sp);
                    //       sp.position.x = x;
                    //       sp.position.y = y;
                    //       sp.position.z = z;
                    // }
                    i++;
                    
                }



                // geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                // try {
                //     geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                //     //logger.innerText = "Colored";
                // }
                // catch(error){
                //     logger.innerText = error;
                // }
                
                // geometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ).setUsage( THREE.DynamicDrawUsage ) );
                // const shaderMaterial = new THREE.PointsMaterial({
                //     size: 0.5, 
                //     map: sprite, 
                //     blending: THREE.AdditiveBlending, 
                //     depthTest: false, 
                //     transparent: true,
                //     vertexColors: THREE.VertexColors
                // })
                // const points = new THREE.Points(geometry, shaderMaterial);
                // //scene.add(points);
                // points.position.set(0, -0, -0);
            
                var guiControls = new function() {
					this.model = 'Temperature4D';
					this.Latitude = 70.05;
					this.Longitude = -160.05;
					this.Elevation = 400;
				};

				var gui = new dat.GUI();
				var modelSelected = gui.add(guiControls, 'model', [ 'Temperature4D', 'Wind', 'VR' ] );
				gui.add(guiControls, 'Latitude', -180.00, 180.00).step(0.05);
                gui.add(guiControls, 'Longitude', -180.00, 180.00).step(0.05);
				gui.add(guiControls, 'Elevation', 0, 400).step(100);
                                
                
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('globe').appendChild(renderer.domElement);

            // const boundingBox = new THREE.Box3().setFromPoints(geometry.attributes.position.array);
            // const wireframeGeometry = new THREE.Box3Helper(boundingBox, 0xffff00);
            // wireframeGeometry.position.set(0.0, 0.0, 0.0);
            // scene.add(wireframeGeometry);
            //logger.innerText = "Temperatur4D";

            scene.add(Globe);
            scene.add(new THREE.AmbientLight(0xcccccc));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.6));

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth/ window.innerHeight, 0.1, 1000);
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            camera.position.z = 400;

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
            controls.target.set(0, 0, 0);
            controls.enablePan = true;
            controls.screenSpacePanning = false;

            window.addEventListener('resize', onWindowResize, false)
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
                renderer.render(scene, camera);
            }

            document.addEventListener("keydown", onDocumentKeyDown, false);
            function onDocumentKeyDown(event){
                var keycode = event.which;
                switch (keycode){
                    case 82:
                        controls.reset();
                        camera.position.z = 4;
                        camera.updateProjectionMatrix()
                        renderer.render(scene,camera);
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    case 37:
                        controls.target.x -= 0.5;
                        camera.position.x -= 0.5;
                        camera.updateProjectionMatrix()
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    case 38:
                        controls.target.y += 0.5;
                        camera.position.y += 0.5;
                        camera.updateProjectionMatrix()
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    case 39:
                        controls.target.x += 0.5;
                        camera.position.x += 0.5;
                        camera.updateProjectionMatrix()
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    case 40: 
                        controls.target.y -= 0.5;
                        camera.position.y -= 0.5;
                        camera.updateProjectionMatrix()
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    case 73:
                        controls.target.z -= 0.5;
                        camera.position.z -= 0.5;
                        camera.updateProjectionMatrix()
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    case 79:
                        controls.target.z += 1;
                        camera.position.z += 1;
                        camera.updateProjectionMatrix()
                        logger.innerText = controls.target.x + " " + controls.target.y + " " + controls.target.z;
                        break;
                    default:
                        break;
                }
                // switch (keycode){
                //     case 82:
                //         controls.reset();
                //         camera.position.z = 4;
                //         camera.updateProjectionMatrix()
                //         renderer.render(scene,camera);
                //         break;
                //     case 37:
                //         scene.position.x += 0.5;
                //         break;
                //     case 38:
                //         scene.position.y -= 0.5;
                //         break;
                //     case 39:
                //         scene.position.x -= 0.5;
                //         break;
                //     case 40: 
                //         scene.position.y += 0.5;
                //         break;
                //     case 73:
                //         scene.position.z += 0.5;
                //         break;
                //     case 79:
                //         scene.position.z -= 0.5;
                //         break;
                //     default:
                //         break;
                // }
            }
                        
            function render(){
                
                renderer.render(scene, camera);
            }
            
            

            (function animate(){
                //logger.innerText += "\n" + Globe.position.x + " " + Globe.position.y + " " + Globe.position.z;
                requestAnimationFrame(animate);
                render();
                controls.update();
            })();
            })
            


        </script>

    </body>
</html>